#' @name generate_command_spec
#'
#' @return A data frame of sub-commands with name, description, functions
#'     invoked and type
generate_command_spec <- function() {
    command_spec <- data.frame(
        name = c(
            'create',
            'preprocess',
            'reduceDim',
            'partition',
            'learnGraph',
            'orderCells',
            'diffExp',
            'plotCells'
        ),
        description = c(
            'Creation of Monocle 3 object from expression and metadata.',
            'Normalisation, scaling, initial dimension reduction.',
            'Reduce dimensionality by UMAP.',
            'Partition cells into groups.',
            'Learn trajectories.',
            'Adjust the start of pseudo-time',
            'Identify genes with varing expression along trajectories.',
            'Visualise trajectories.'
        ),
        functions = c(
            'createCDS',
            'preprocessCDS',
            'reduceDimension',
            'partitionCells',
            'learnGraph',
            'orderCells,get_root_principal_nodes',
            'principalGraphTest',
            'plot_cell_trajectory'
        ),
        type = c('o','io', 'io', 'io', 'io', 'io', 'it', 'ip'),
        stringsAsFactors = FALSE
    )
    rownames(command_spec) <- command_spec$name
    command_spec
}

#' @name generate_command_usage
#' 
#' @param command_spec sub-command specification table generated by
#'     generate_command_spec()
#' @return Formatted usage text for the master command
generate_command_usage <- function(command_spec) {
    usage <- paste(
        'Usage: monocle3 [-h] <command> ...',
        '',
        'Commands:',
        paste(
            sprintf('  %-17s %-60s', command_spec$name, command_spec$description),
            collapse = '\n'
        ),
        '',
        'Options:',
        sprintf('  %-17s %-60s', '-h, --help', 'Show this help message and exit'),
        sep = '\n'
    )
}

#' Prepend function option names with function name, add options of common
#' functions according to command type
prepare_option_spec <- function(cmd_spec) {
    cmd_functions <- unlist(strsplit(cmd_spec$functions, ','))
    fn_options <- function_options(cmd_functions)
    for (i in seq_along(fn_options)) {
        fn_name <- cmd_functions[i]
        for (j in seq_along(fn_options[[i]])) {
            dest <- fn_options[[i]][[j]]@dest
            fn_options[[i]][[j]]@dest <- paste(fn_name, dest, sep = '___')
        }
    }
    option_spec <- do.call('c', fn_options)
    if (grepl('p', cmd_spec$type)) option_spec <- c(output_plot_options(), option_spec)
    if (grepl('t', cmd_spec$type)) option_spec <- c(output_table_options(), option_spec)
    if (grepl('o', cmd_spec$type)) option_spec <- c(output_object_options(), option_spec)
    if (grepl('i', cmd_spec$type)) option_spec <- c(input_options(), option_spec)
    option_spec <- c(option_spec, common_options())
}

#' Remove function name prefix from parsed option names, aggregate options from
#' the same function into separate lists
prepare_parsed_options <- function(opts, cmd_spec) {
    cmd_functions <- unlist(strsplit(cmd_spec$functions, ','))
    new_opts <- list()
    for (fn_name in cmd_functions) {
        fn_prfx <- paste0('^', fn_name, '___')
        k <- grep(fn_prfx, names(opts))
        names(opts)[k] <- sub(fn_prfx, '', names(opts)[k])
        new_opts[[paste0(fn_name, '_options')]] <- opts[k]
        opts[k] <- NULL
    }
    opts$help <- NULL
    c(opts, new_opts)
}

#' @name monocle_create
#'
monocle_create <- function(
    output_object,
    output_object_format = 'cds3',
    introspective = FALSE,
    verbose = FALSE,
    createCDS_options = list()
) {

    if (is.null(createCDS_options[['expression_matrix']]))
    {
        message('You need to provide the expression matrix by --expression-matrix. Aborting.')
        q(save = 'no', status = 1)
    }
    #helper variable for dimension compatibility check later
    #a newly imported TSV/CSV's dimension 1 is compared against the count matrix dimension...?
    dims = list()
    #introduces less logic downstream to just have it check itself
    dims[['expression_matrix']] = 1
    dims[['cell_metadata']] = 2
    dims[['gene_annotation']] = 1
    
    #the three constituents of the new_cell_data_set() call
    #are passed as arguments to the function, and live in this list
    for (var in c('expression_matrix','cell_metadata', 'gene_annotation'))
    {
        file = createCDS_options[[var]]
        if (is.null(file))
            assign(var, NULL)
        else
        {
            if (toupper(substr(file, nchar(file)-2, nchar(file))) == 'RDS')
                assign(var, readRDS(file))
            else if (toupper(substr(file, nchar(file)-2, nchar(file))) == 'MTX')
                assign(var, Matrix::readMM(file))
            else
            {
                #select correct delimiter for tsv or csv file
                sep=','
                if (toupper(substr(file, nchar(file)-2, nchar(file))) == 'TSV')
                    sep='\t'
                assign(var, as.matrix(read.delim(file, sep=sep, row.names = 1, stringsAsFactors = FALSE, check.names=FALSE)))
                #dimensionality check to account for the possible lack of a header
                if (dim(get(var))[1] != dim(expression_matrix)[dims[[var]]])
                {
                    if (dim(get(var))[1] == dim(expression_matrix)[dims[[var]]]-1)
                        assign(var, as.matrix(read.delim(file, sep=sep, row.names = 1, header=FALSE, stringsAsFactors = FALSE)))
                    else
                    {
                        message(paste('Dimensionality mismatch between',file,'and expression matrix. Exiting'))
                        q(save = 'no', status = 1)
                    }
                }
            }
        }
    }
    
    #a bit of 10x compatibility - the genes/features tsv file does not come with column names
    #generate some automatic column names
    if (!is.null(createCDS_options[['gene_annotation']]))
    {
        if (basename(createCDS_options[['gene_annotation']]) == 'genes.tsv')
            colnames(gene_annotation) = c('gene_short_name')
        if (basename(createCDS_options[['gene_annotation']]) == 'features.tsv')
            colnames(gene_annotation) = c('gene_short_name', 'feature_type')
    }

    cds = new_cell_data_set(expression_matrix,
                            cell_metadata = cell_metadata,
                            gene_metadata = gene_annotation)
    
    monocle_write_obj(cds, output_object, output_object_format, introspective)
}

#' @name monocle_preprocess
#'
#' @importFrom BiocGeneric estimateSizeFactors estimateDispersions
#' @importFrom monocle3 preprocess_cds
monocle_preprocess <- function(
    input_object,
    output_object,
    input_object_format = 'cds3',
    output_object_format = 'cds3',
    introspective = FALSE,
    verbose = FALSE,
    preprocessCDS_options = list()
) {
    cds <- monocle_read_obj(input_object, input_object_format)

	#the current (08.08.19) monocle3 tutorial doesn't do this anymore, so commenting out
    #cds <- estimateSizeFactors(cds)
    #cds <- estimateDispersions(cds)

    cds <- do.call(
        'preprocess_cds',
        c(list(cds, verbose=verbose), preprocessCDS_options)
    )

    monocle_write_obj(cds, output_object, output_object_format, introspective)
}

#' @name monocle_reduceDim
#'
#' @importFrom monocle3 reduce_dimension
monocle_reduceDim <- function(
    input_object,
    output_object,
    input_object_format = 'cds3',
    output_object_format = 'cds3',
    introspective = FALSE,
    verbose = FALSE,
    reduceDimension_options = list()
) {
    cds <- monocle_read_obj(input_object, input_object_format)

    cds <- do.call(
        'reduce_dimension',
        c(list(cds, verbose = verbose), reduceDimension_options)
    )

    monocle_write_obj(cds, output_object, output_object_format, introspective)
}

#' @name monocle_partition
#'
#' @importFrom monocle3 cluster_cells
monocle_partition <- function(
    input_object,
    output_object,
    input_object_format = 'cds3',
    output_object_format = 'cds3',
    introspective = FALSE,
    verbose = FALSE,
    partitionCells_options = list()
) {
    cds <- monocle_read_obj(input_object, input_object_format)

    cds <- do.call(
        'cluster_cells',
        c(list(cds, verbose = verbose), partitionCells_options)
    )

    monocle_write_obj(cds, output_object, output_object_format, introspective)
}

#' @name monocle_learnGraph
#'
#' @importFrom monocle3 learn_graph
monocle_learnGraph <- function(
    input_object,
    output_object,
    input_object_format = 'cds3',
    output_object_format = 'cds3',
    introspective = FALSE,
    verbose = FALSE,
    learnGraph_options = list()
) {
    cds <- monocle_read_obj(input_object, input_object_format)

    learn_graph_control <- list()
    for (opt in c(
            'euclidean_distance_ratio',
            'geodesic_distance_ratio',
            'minimal_branch_len',
            'orthogonal_proj_tip',
            'prune_graph')
    ) {
        learn_graph_control[[opt]] <- learnGraph_options[[opt]]
        learnGraph_options[[opt]] <- NULL
    }

    cds <- do.call(
        'learn_graph',
        c(list(cds, verbose = verbose, learn_graph_control = learn_graph_control),
          learnGraph_options)
    )

    monocle_write_obj(cds, output_object, output_object_format, introspective)
}

#' @name monocle_orderCells
#'
#' @importFrom monocle3 order_cells
monocle_orderCells <- function(
    input_object,
    output_object,
    input_object_format = 'cds3',
    output_object_format = 'cds3',
    introspective = FALSE,
    verbose = FALSE,
    get_root_principal_nodes_options = list(),
    orderCells_options = list()
) {
    cds <- monocle_read_obj(input_object, input_object_format)

    if (is.null(orderCells_options$root_pr_nodes) &&
        is.null(orderCells_options$root_cells)) {
        orderCells_options$root_pr_nodes <- do.call(
            'get_root_principal_nodes',
            c(list(cds), get_root_principal_nodes_options)
        )
    }

    cds <- do.call(
        'order_cells',
        c(list(cds, verbose = verbose), orderCells_options)
    )

    monocle_write_obj(cds, output_object, output_object_format, introspective)
}

#' @name monocle_diffExp
#'
#' @importFrom monocle3 graph_test
monocle_diffExp <- function(
    input_object,
    output_table,
    input_object_format = 'cds3',
    output_table_format = 'tsv',
    introspective = FALSE,
    verbose = FALSE,
    principalGraphTest_options = list()
) {
    cds <- monocle_read_obj(input_object, input_object_format)

    cds <- do.call(
        'graph_test',
        c(list(cds, verbose = verbose), principalGraphTest_options)
    )

    monocle_write_table(cds, output_table, output_table_format, introspective)
}

#' @name monocle_plotCells
#'
#' @importFrom monocle3 plot_cells
monocle_plotCells <- function(
    input_object,
    output_plot,
    input_object_format = 'cds3',
    output_plot_format = 'png',
    verbose = FALSE,
    plot_cell_trajectory_options = list()
) {
    cds <- monocle_read_obj(input_object, input_object_format)

    p <- do.call(
        'plot_cells',
        c(list(cds), plot_cell_trajectory_options)
    )

    monocle_write_plot(p, output_plot, output_plot_format)
}
