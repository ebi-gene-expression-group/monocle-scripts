#' @name generate_command_spec
#'
#' @return A data frame of sub-commands with name, description, functions
#'     invoked and type
generate_command_spec <- function() {
    command_spec <- data.frame(
        name = c(
            'create',
            'preprocess',
            'reduceDim',
            'partition',
            'learnGraph',
            'orderCells',
            'diffExp',
            'plotCells'
        ),
        description = c(
            'Creation of Monocle 3 object from expression and metadata.',
            'Normalisation, scaling, initial dimension reduction.',
            'Reduce dimensionality by UMAP.',
            'Partition cells into groups.',
            'Learn trajectories.',
            'Adjust the start of pseudo-time',
            'Identify genes with varing expression along trajectories.',
            'Visualise trajectories.'
        ),
        functions = c(
            'createCDS',
            'preprocessCDS',
            'reduceDimension',
            'partitionCells',
            'learnGraph',
            'orderCells,get_root_principal_nodes',
            'principalGraphTest',
            'plot_cell_trajectory'
        ),
        type = c('o','io', 'io', 'io', 'io', 'io', 'it', 'ip'),
        stringsAsFactors = FALSE
    )
    rownames(command_spec) <- command_spec$name
    command_spec
}

#' @name generate_command_usage
#' 
#' @param command_spec sub-command specification table generated by
#'     generate_command_spec()
#' @return Formatted usage text for the master command
generate_command_usage <- function(command_spec) {
    usage <- paste(
        'Usage: monocle3 [-h] <command> ...',
        '',
        'Commands:',
        paste(
            sprintf('  %-17s %-60s', command_spec$name, command_spec$description),
            collapse = '\n'
        ),
        '',
        'Options:',
        sprintf('  %-17s %-60s', '-h, --help', 'Show this help message and exit'),
        sep = '\n'
    )
}

#' Prepend function option names with function name, add options of common
#' functions according to command type
prepare_option_spec <- function(cmd_spec) {
    cmd_functions <- unlist(strsplit(cmd_spec$functions, ','))
    fn_options <- function_options(cmd_functions)
    for (i in seq_along(fn_options)) {
        fn_name <- cmd_functions[i]
        for (j in seq_along(fn_options[[i]])) {
            dest <- fn_options[[i]][[j]]@dest
            fn_options[[i]][[j]]@dest <- paste(fn_name, dest, sep = '___')
        }
    }
    option_spec <- do.call('c', fn_options)
    if (grepl('p', cmd_spec$type)) option_spec <- c(output_plot_options(), option_spec)
    if (grepl('t', cmd_spec$type)) option_spec <- c(output_table_options(), option_spec)
    if (grepl('o', cmd_spec$type)) option_spec <- c(output_object_options(), option_spec)
    if (grepl('i', cmd_spec$type)) option_spec <- c(input_options(), option_spec)
    option_spec <- c(option_spec, common_options())
}

#' Remove function name prefix from parsed option names, aggregate options from
#' the same function into separate lists
prepare_parsed_options <- function(opts, cmd_spec) {
    cmd_functions <- unlist(strsplit(cmd_spec$functions, ','))
    new_opts <- list()
    for (fn_name in cmd_functions) {
        fn_prfx <- paste0('^', fn_name, '___')
        k <- grep(fn_prfx, names(opts))
        names(opts)[k] <- sub(fn_prfx, '', names(opts)[k])
        new_opts[[paste0(fn_name, '_options')]] <- opts[k]
        opts[k] <- NULL
    }
    opts$help <- NULL
    c(opts, new_opts)
}

#' @name monocle_create
#'
monocle_create <- function(
    output_object,
    output_object_format = 'cds3',
    introspective = FALSE,
    verbose = FALSE,
    createCDS_options = list()
) {

    if (is.null(createCDS_options[['expression_matrix']]))
    {
        message('You need to provide the expression matrix by --expression-matrix. Aborting.')
        q(save = 'no', status = 1)
    }

    .parse_input_data = function(file_type){
        if(! file_type %in% c('expression_matrix', 'cell_metadata', 'gene_annotation'))
            stop(paste("Incorrect argument provided", file_type))

        file = createCDS_options[[file_type]]

        if (is.null(file)) 
            return(NULL)
        ext = toupper(substr(file, nchar(file)-2, nchar(file)))
        if (ext == 'RDS') 
            return(readRDS(file))
        if (ext == 'MTX')
            return(Matrix::readMM(file))

        # handle different text formats
        if (ext == 'TSV') 
            sep = "\t"
        else sep = ","

        # Read file once, and adjust row/columns as appropriate before
        # returning as matrix

        if ( file_type == 'expression_matrix' ){
            mat = as.matrix(read.delim(file, sep = sep, stringsAsFactors = FALSE, row.names = 1)) 
        }else{
            mat = read.delim(file, sep = sep, stringsAsFactors = FALSE, row.names = NULL) 
            dim_to_check = ifelse(file_type == 'cell_metadata', 2, 1)

            expected_rows = dim(expression_matrix)[dim_to_check]

            if (nrows(mat) != expected_rows){
                if (nrows(mat) - 1 == expected_rows){
                    mat <- mat[-1,]
                }else{
                    message(paste('Number of', file_type, 'entries not appropriate to matrix.'))
                    q(save = 'no', status = 1)
                }
            }

            # Move first column into rownames where possible

            rownames(mat) <- mat[,1]
            if (ncol(mat) > 1){
                mat <- mat[,-11]
            }

            mat <- as.matrix(mat)
        }
    }

    expression_matrix = .parse_input_data('expression_matrix')
    cell_metadata = .parse_input_data('cell_metadata')
    gene_annotation = .parse_input_data('gene_annotation')

    # matrix entries need to be named
    if(!is.null(gene_annotation)){
        row.names(expression_matrix) = row.names(gene_annotation)
    }
    if(!is.null(cell_metadata)){
        colnames(expression_matrix) = row.names(cell_metadata)
    }

    cds = new_cell_data_set(expression_matrix,
                            cell_metadata = cell_metadata,
                            gene_metadata = gene_annotation)
    
    monocle_write_obj(cds, output_object, output_object_format, introspective)
}

#' @name monocle_preprocess
#'
#' @importFrom BiocGeneric estimateSizeFactors estimateDispersions
#' @importFrom monocle3 preprocess_cds
monocle_preprocess <- function(
    input_object,
    output_object,
    input_object_format = 'cds3',
    output_object_format = 'cds3',
    introspective = FALSE,
    verbose = FALSE,
    preprocessCDS_options = list()
) {
    cds <- monocle_read_obj(input_object, input_object_format)

	#the current (08.08.19) monocle3 tutorial doesn't do this anymore, so commenting out
    #cds <- estimateSizeFactors(cds)
    #cds <- estimateDispersions(cds)

    cds <- do.call(
        'preprocess_cds',
        c(list(cds, verbose=verbose), preprocessCDS_options)
    )

    monocle_write_obj(cds, output_object, output_object_format, introspective)
}

#' @name monocle_reduceDim
#'
#' @importFrom monocle3 reduce_dimension
monocle_reduceDim <- function(
    input_object,
    output_object,
    input_object_format = 'cds3',
    output_object_format = 'cds3',
    introspective = FALSE,
    verbose = FALSE,
    reduceDimension_options = list()
) {
    cds <- monocle_read_obj(input_object, input_object_format)

    cds <- do.call(
        'reduce_dimension',
        c(list(cds, verbose = verbose), reduceDimension_options)
    )

    monocle_write_obj(cds, output_object, output_object_format, introspective)
}

#' @name monocle_partition
#'
#' @importFrom monocle3 cluster_cells
monocle_partition <- function(
    input_object,
    output_object,
    input_object_format = 'cds3',
    output_object_format = 'cds3',
    introspective = FALSE,
    verbose = FALSE,
    partitionCells_options = list()
) {
    cds <- monocle_read_obj(input_object, input_object_format)

    cds <- do.call(
        'cluster_cells',
        c(list(cds, verbose = verbose), partitionCells_options)
    )

    monocle_write_obj(cds, output_object, output_object_format, introspective)
}

#' @name monocle_learnGraph
#'
#' @importFrom monocle3 learn_graph
monocle_learnGraph <- function(
    input_object,
    output_object,
    input_object_format = 'cds3',
    output_object_format = 'cds3',
    introspective = FALSE,
    verbose = FALSE,
    learnGraph_options = list()
) {
    cds <- monocle_read_obj(input_object, input_object_format)

    learn_graph_control <- list()
    for (opt in c(
            'euclidean_distance_ratio',
            'geodesic_distance_ratio',
            'minimal_branch_len',
            'orthogonal_proj_tip',
            'prune_graph')
    ) {
        learn_graph_control[[opt]] <- learnGraph_options[[opt]]
        learnGraph_options[[opt]] <- NULL
    }

    cds <- do.call(
        'learn_graph',
        c(list(cds, verbose = verbose, learn_graph_control = learn_graph_control),
          learnGraph_options)
    )

    monocle_write_obj(cds, output_object, output_object_format, introspective)
}

#' @name monocle_orderCells
#'
#' @importFrom monocle3 order_cells
monocle_orderCells <- function(
    input_object,
    output_object,
    input_object_format = 'cds3',
    output_object_format = 'cds3',
    introspective = FALSE,
    verbose = FALSE,
    get_root_principal_nodes_options = list(),
    orderCells_options = list()
) {
    cds <- monocle_read_obj(input_object, input_object_format)

    if (is.null(orderCells_options$root_pr_nodes) &&
        is.null(orderCells_options$root_cells)) {
        orderCells_options$root_pr_nodes <- do.call(
            'get_root_principal_nodes',
            c(list(cds), get_root_principal_nodes_options)
        )
    }

    cds <- do.call(
        'order_cells',
        c(list(cds, verbose = verbose), orderCells_options)
    )

    monocle_write_obj(cds, output_object, output_object_format, introspective)
}

#' @name monocle_diffExp
#'
#' @importFrom monocle3 graph_test
monocle_diffExp <- function(
    input_object,
    output_table,
    input_object_format = 'cds3',
    output_table_format = 'tsv',
    introspective = FALSE,
    verbose = FALSE,
    principalGraphTest_options = list()
) {
    cds <- monocle_read_obj(input_object, input_object_format)

    cds <- do.call(
        'graph_test',
        c(list(cds, verbose = verbose), principalGraphTest_options)
    )

    monocle_write_table(cds, output_table, output_table_format, introspective)
}

#' @name monocle_plotCells
#'
#' @importFrom monocle3 plot_cells
monocle_plotCells <- function(
    input_object,
    output_plot,
    input_object_format = 'cds3',
    output_plot_format = 'png',
    verbose = FALSE,
    plot_cell_trajectory_options = list()
) {
    cds <- monocle_read_obj(input_object, input_object_format)

    p <- do.call(
        'plot_cells',
        c(list(cds), plot_cell_trajectory_options)
    )

    monocle_write_plot(p, output_plot, output_plot_format)
}
